---
layout: post
title: "Simplifying NoSQL Database Integration with Jakarta NoSQL"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/dearrudam
author_github: https://github.com/dearrudam
seo-title: TITLE - OpenLiberty.io
seo-description: In the data-driven age of AI and cloud computing, the choice of data storage—relational or NoSQL databases—crucially influences a solution's success. For relational databases within Java, the Java Persistence API (JPA) is the established standard. However, NoSQL databases have lacked standardization, leaving developers to navigate a plethora of vendor-specific solutions. The Jakarta NoSQL specification addresses this gap by providing a standard-based, easy-to-learn framework that mirrors the familiar JPA, simplifying development across various NoSQL databases. This post will delve into how Jakarta NoSQL together with Jakarta Data can ease the development process for Java developers using NoSQL databases.

blog_description: "In the data-driven age of AI and cloud computing, the choice of data storage—relational or NoSQL databases—crucially influences a solution's success. For relational databases within Java, the Java Persistence API (JPA) is the established standard. However, NoSQL databases have lacked standardization, leaving developers to navigate a plethora of vendor-specific solutions. The Jakarta NoSQL specification addresses this gap by providing a standard-based, easy-to-learn framework that mirrors the familiar JPA, simplifying development across various NoSQL databases. This post will delve into how Jakarta NoSQL together with Jakarta Data can ease the development process for Java developers using NoSQL databases."
open-graph-image: https://openliberty.io/img/twitter_card.jpg
open-graph-image-alt: Open Liberty Logo
---
= Simplifying NoSQL Database Integration with Jakarta NoSQL
Maximillian Arruda <https://github.com/dearrudam>
:imagesdir: /
:url-prefix:
:url-about: /


// // // // // // // //
// In the preceding section:
// Do not insert any blank lines between any of the lines.
//
// "open-graph-image" is set to OL logo. Whenever possible update this to a more appropriate/specific image (For example if present a image that is being used in the post). However, it
// can be left empty which will set it to the default
//
// "open-graph-image-alt" is a description of what is in the image (not a caption). When changing "open-graph-image" to
// a custom picture, you must provide a custom string for "open-graph-image-alt".
//
// Replace DESCRIPTION with a short summary (~60 words) of the release (a more succinct version of the first paragraph of the post).
//
// If adding image into the post add :
// -------------------------
// [.img_border_light]
// image::img/blog/FILE_NAME[IMAGE CAPTION ,width=70%,align="center"]
// -------------------------
// "[.img_border_light]" = This adds a faint grey border around the image to make its edges sharper. Use it around screenshots but not
// around diagrams. Then double check how it looks.
// There is also a "[.img_border_dark]" class which tends to work best with screenshots that are taken on dark backgrounds.
// Change "FILE_NAME" to the name of the image file. Also make sure to put the image into the right folder which is: img/blog
// change the "IMAGE CAPTION" to a couple words of what the image is
// // // // // // // //

In the data-driven age of AI and cloud computing, choosing the right data storage solution directly impacts the success of a solution. We currently have two major data storage approaches to rely on: relational and NoSQL databases. Within the Java space, when it comes to working with relational databases, the Java Persistence API (JPA) specification has undoubtedly established itself as a robust and widely adopted API. In contrast, the crowded landscape of NoSQL database options opens a large set of integration options for developers, who instead of relying on standards, often find themselves learning and depending on vendor's proposed solutions.

> "The way you define data storage and code design will either facilitate or hinder the project's maintainability, performance, scalability, and ability to change databases later on."

Fortunately, the Java community adopting NoSQL storage solutions no longer needs to worry about these concerns. The Jakarta NoSQL specification offers a well-defined, standard-based implementation with low learning curve and familiar coding APIs, thanks to its similarities with the widely-adopted JPA specification.

Join us in this comprehensive article as we explore Jakarta NoSQL and how this specification can simplify developers' lives, no matter which NoSQL database is used by their applications!

== Introduction to NoSQL

=== Understanding NoSQL Databases

The market has different views on the meaning of the name "NoSQL": while some believe it is an acronym for "Not Only SQL", others understand it as "Non-SQL" or "Not relational". Regardless of these different interpretations, there's an undeniable aspect of this solution: *NoSQL databases are fundamentally different in terms of data storage and management when compared to SQL*.

==== Key Differences: SQL vs NoSQL
By looking into the differences between SQL and NoSQL, we can notice the following differences:

|===
|Description |SQL Databases |NoSQL Databases

|_Data Storage_
|Use tabular relations to store and retrieve data
|Provide mechanisms for retrieving and storing unstructured and semi-structured data (non-relational)

|_Schema_
|Predefined schemas
|No predefined schemas

|_Scalability_
|Vertical scalability (scale up)
|Horizontal scalability (scale out)

|_Data Distribution_
|Data distributed across fewer servers
|Data distributed across many servers

|_Suitability_
|Better suited for smaller, structured datasets
|Well-suited for handling large and growing datasets

|_Industry Adoption_
|Traditionally used in many industries
|Gaining popularity in industries like finance and streaming

|===

Now that we've explored fundamental differences between SQL and NoSQL databases, let's have an overview of the different types of NoSQL databases, each designed to solve specific problems with unique data models and architectures.

==== Exploring NoSQL Database Types

In the NoSQL space, each database type aims to solve different needs. Below is an overview of the *Key-Value*, *Document*, *Column*, and *Graph* databases, the most popular non-relational storage approaches;

===== Key-Value Databases

The simplest storage types approach of the NoSQL database types. Data is stored as a collection of key-value pairs. It's ideal for getting information when you know the specific key, like finding a contact in your phone by their name.The structure resembles the Java `java.util.Map` API, where values are mapped to keys.

Key-value databases are often used for caching, session management, and message queues.

[.img_border_light]
image::/img/blog/key-value-nosql.png[Key-value database type,align="center" width=25%,height=25%]

Here are examples of vendors currently offering key-value solutions: *Amazon DynamoDB*, *Redis*, *Hazelcast* and *Memcached*. The last three are open source technologies.

===== Document Databases

Document databases are designed to store, retrieve, and manage documents with minimally defined structures, such as XML and JSON formats.A document without a predefined structure is a data model that may be composed of multiple fields to hold different data types.

Since it's possible to design models that holds documents inside other documents, Domain-Driven Design (DDD) practitioners, can leverage document aggregates to manage their derived entities in a hierarchical structure.

Document databases are well-suited for managing unstructured data, such as user profiles, product catalogs, or content management systems.

[.img_border_light]
image::/img/blog/document-nosql.png[Document database type,align="center" width=25%,height=25%]

Key vendors providing document database solutions are: *MongoDB*, *Couchbase*, *Elastic*, *Oracle NoSQL Database*.

===== Column Databases

The Column databases (also known as column-oriented or wide-column databases) store data as columns instead of rows (common in traditional relational databases). This approach is a differentiator across other types, as it's an efficient way to handle large amounts of data and run performant complex queries.

This type is designed and optimized for storing large amounts of structured, semi-structured, and unstructured data with a flexible schema, and supports high levels of concurrency and scalability.

Wide-column databases are often used for analytics, content management, and data warehousing.

[.img_border_light]
image::/img/blog/column-nosql.png[Column database type,align="center" width=25%,height=25%]

Examples of Column databases on the market include *Apache HBase*, *Apache Cassandra*, *Scylla*, *Azure Cosmos DB*, and many others. The first two mentioned here are open source technologies.

===== Graph Databases

The Graph NoSQL database is optimized for storing and querying data with complex relationships. In this approach, data is managed as a graph where entities can be represented as nodes and edges, resulting in performant management of complex relationship and hierarchies.

The graph data resembles the graph of objects in the Oriented-Object Programming (OOP) paradigm. Graph NoSQL database solutions is a good fit for scenarios that require fast querying of highly interconnected data, such as social networks, recommendation engines, and fraud detection systems.

[.img_border_light]
image::/img/blog/graph-nosql.png[Graph database type,align="center" width=25%,height=25%]

Engines to choose from today, are *Neo4J*, *Arango DB*, *OrientDB*, *JanusGraph*, among others. The last one mentioned is open source technologies.

==== Challenges of NoSQL Integration

Modern solution's requirements frequently requires the capabilities and benefits of different types of NoSQL databases, therefore, we should be able to work with multiple NoSQL solutions, coming from different vendors. Having said that, we can expect to face challenges such as:

* A high cognitive load necessary when choosing a NoSQL database for their solutions;
* A significant learning curve derived from usage of different database APIs;
* Extra time invested on changing/maintaining existing codebase;
* Potentially increase in complexity when onboarding new developers to the team;

Furthermore, in the cloud era and the consumption-based pricing models, we must consider ways to deliver solutions with efficient resource consumption for costs reduction. This is how potential discussions may rise, opening possibility for considering changes of the underlying database used by existing applications.

In addition to the challenges above, a solution based on NoSQL must be flexible and designed with a concise isolation between business logic and the underlying persistence layer given the high probability of changes being made to both layers.

[NOTE]
As of February 2024, the https://db-engines.com/en/ranking[DB-Engines Ranking], an initiative that aims to list and rank DBMS by popularity, there are over **180 non-relational/NoSQL databases available in the market**.

To solve these mentioned challenges, we can refer to a not so distant past, when we faced a similar challenge with relational databases and Java integration. The JDBC (Java Database connectivity) was created to standardize the way Java integrates with relational databases. To better align it with the OOP paradigm, the ORM pattern popularized and the Jakarta Persistence specification was created to facilitate working with different relational databases engines and vendors.

So, based on this background context about solutions with Jakarta Persistence, wouldn't it be interesting to have a similar solution and APIs to work with NoSQL?

*Say hello to https://jakarta.ee/specifications/nosql/[Jakarta NoSQL] and https://jakarta.ee/specifications/data/[Jakarta Data]!*

== Introducing Jakarta NoSQL and Jakarta Data

These are specifications proposing a simpler NoSQL integration and abstract aspects of database vendors, allowing for developers to manipulate data with intuitive and developer-friendly APIs.

=== Jakarta NoSQL

https://jakarta.ee/specifications/nosql/[Jakarta NoSQL] is a https://jakarta.ee/[Jakarta EE] specification designed to easily integrate Java and NoSQL databases. It uses common annotations and specific APIs for key-value, column, and document databases.

=== Jakarta Data

The https://jakarta.ee/specifications/data/[Jakarta Data] specification, part of https://jakarta.ee/[Jakarta EE], proposes a unified API for simplified data access across different types of databases, from relational to NoSQL databases.

Jakarta Data achieves its goal by introducing concepts like Repositories and custom query methods, improving the developer experience when using data retrieval and manipulation APIs.

[NOTE]
Jakarta Data is planned for officially becoming part of https://jakarta.ee/specifications/data/1.0/[Jakarta EE 11]

=== Eclipse JNoSQL: A Reference Implementation

A Jakarta EE Specification can't solve the problem by itself - it becomes consumable through an _implementation_.

Each Jakarta EE Specification has at least one implementation. The existance of an implementation proves the proposed specification is achievable and can be developed by interested third-parties. This is when companies and communities actively starts providing their own implementations, empowering the Jakarta EE developers and ecosystem with a diverse and powerful toolset.

[NOTE]
    Example of reference implementations (RI) are Hibernate for Jakarta Persistence 3.1 specification; Jersey for Jakarta RESTFul Web Services 3.1 specification; Glassfish for Jakarta Servlet 6.0 specification; Weld for Jakarta Context And Dependency Injection (CDI) 4.0 specification; and so on...

https://projects.eclipse.org/projects/technology.jnosql[*Eclipse JNoSQL*] is a compatible implementation of the *Jakarta NoSQL* and *Jakarta Data* specifications, a framework that streamlines the integration of Java applications with relational and NoSQL databases. Powered by the Jakarta Contexts and Dependency Injection (CDI) specification, it is compatible with Jakarta EE and Eclipse MicroProfile compatible solutions.

Eclipse JNoSQL covers four NoSQL database types: *key-value*, *column*, *document* and *graph* databases.

[NOTE]
Currently, the Jakarta NoSQL doesn't define an API for Graph database types but Eclipse JNoSQL provides a Graph template to explore the specific behavior of this database type by using https://tinkerpop.apache.org/[Apache TinkerPop] as a communication layer.

As of March 2024, Eclipse JNoSQL supports about https://www.jnosql.org/docs/supported_dbs.html[30 NoSQL databases].

==== Why Eclipse JNoSQL?

In the code samples below, note the APIs similarities and differences accross different vendors. All samples demonstrate a commonly used functionality for Document databases: a document creation and the addition of a property to that document:

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/mongodb.png[MongoDB ,align="left" width=25%,height=25%]
[source, java]
----
Document document = new Document();
document.append(name, value);
----
****

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/ArangoDB.png[Arango DB,align="left" width=25%,height=25%]
[source, java]
----
BaseDocument baseDocument = new BaseDocument();
baseDocument.addAttribute(name, value);
----
****

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/couchbase.svg[Couchbase,align="left" width=25%,height=25%]
[source, java]
----
JsonObject jsonObject = JsonObject.create();
jsonObject.put(name, value);
----
****

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/orientdb.png[Orient Project,align="left" width=25%,height=25%]
[source, java]
----
ODocument document = new ODocument("collection");
document.field(name, value);
----
****

With Eclipse JNoSQL, developers can use a common API to integrate with different database types, free of vendor lock-in, and with a low cognitive load during learning phases. For example, using the Document API, it's possible to switch between MongoDB and ArangoDB as needed, based on Convention Over Configuration (CoC).

[.img_border_light]
****
image::https://jnosql.github.io/images/home_logo.png[Orient Project,align="left" width=25%,height=25%]
[source, java]
----
DocumentEntity entity = DocumentEntity.of("collection");
entity.add(name, value);
----
****

Check out some of the Jakarta NoSQL annotations:

[source, java]
----
import jakarta.nosql.Entity;
import jakarta.nosql.Id;
import jakarta.nosql.Column;

@Entity
public class Book {

    @Id
    private String isbn;

    @Column
    private String title;

    @Column
    private String author;

    @Convert(YearConverter.class)
    @Column
    private Year year;

}
----

When using Java 17+, Eclipse JNoSQL allows the usage of Java Records as entities:

[source, java]
----
import jakarta.nosql.Entity;
import jakarta.nosql.Id;
import jakarta.nosql.Column;

@Entity
public record Book(@Id String isbn,
                   @Column("title") String title,
                   @Column("author") String author,
                   @Convert(YearConverter.class) @Column("year") Year year,
                   @Column("edition") int edition) {

}

----

Last but not least, Eclipse JNoSQL, as a Jakarta Data implementation, allows us to create repositories, enabling Domain-Driven Development (DDD) capabilities through the usage of the Repository pattern. This approach simplifies developers who seek to bring the code closer to the business (domain-centric) instead of working with database semantics.

[source,java]
----
import jakarta.data.page.Page;
import jakarta.data.page.Pageable;
import jakarta.data.repository.Delete;
import jakarta.data.repository.Repository;
import jakarta.data.repository.PageableRepository;
import jakarta.data.repository.Query;
import jakarta.data.repository.Param;
import jakarta.data.repository.Save;

@Repository
public interface Garage extends PageableRepository<Car,String>{

    @Save
    Car park(Car car);

    @Delete
    Car unPark(Car car);

    @Query("select * from Car where driver.name = @name")
    Set<Car> findByDriver(@Param("name") String name);

    Page<Car> findByColor(Color color, Pageable pageable);

}
----

==== What to expect from Eclipse JNoSQL

Beyond being a Jakarta NoSQL and Jakarta Data implementation, such framework intents to reaching out these goals:

* Increase productivity performing common NoSQL operations
* Use of Convention Over Configuration
* Rich Object Mapping integrated with Contexts and Dependency Injection (CDI)
* Java-based Query and Fluent-API
* Persistence lifecycle events
* Low-level mapping using Standard NoSQL APIs
* Specific template API to each NoSQL category
* Annotation-oriented using JPA-like naming when it makes sense
* Extensible to explore the particular behavior of a NoSQL database
* Explore the popularity of Apache TinkerPop in Graph API

After getting an overview about the Jakarta NoSQL, Jakarta Data, and the Eclipse JNoSQL, let's explore on a hands-on approach how we could use and forest these features in an interesting project, managing and querying data from NoSQL databases and switching between NoSQL databases as needed.

== Eclipse JNoSQL in Action: JNopo Game

Let's now understand how an actual implementation would look like, through a sample game application that relies on non-relational storage and data manipulation.

=== Getting Started: Playing JNopo!

*JNopo* game is a Java version of the famous the _Rock, Paper, and Scissors_ game. This game consists of a battle of two players where each one chooses a movement between rock, paper, or scissors. To illustrate the game logic, let's suppose that a _Player A_ will play with a _Player B_ and, in this case:

* If _Player A_ chooses _ROCK_ and _Player B_ chooses _SCISSORS_ then _Player A_ wins the game.
* If _Player A_ chooses _PAPER_ and _Player B_ chooses _ROCK_ then _Player A_ wins the game.
* If _Player A_ chooses _SCISSORS_ and _Player B_ chooses _PAPER_ then _Player A_ wins the game.
* If _Player A_ and _Player B_ choose the same movement then no one wins, and a tied game happens.

In the sequence diagram below we can illustrate the default behavior of the JNopo game:

[.img_border_light]
image::/img/blog/jnopo-sequence-diagram-without-persistence.gif[JNopo Sequence Diagram, align="center" width=60%]

*JNopo* is a game implemented using Jakarta EE Specifications, which means, it's compatible with Jakarta EE and MicroProfile runtimes, and in our case we're using https://openliberty.io/[Open Liberty] 23.0.0.10.

The architecture for this application is composed by two components:

* The web page where the players interact to the game;

* The back-end where the game matches are managed;

In the image below we can see the system design of the JNopo game:

[.img_border_light]
image::/img/blog/jnopo-architecture-without-persistence.png[JNopo Architecture Diagram, align="center" width=60%]

=== It's fun time: Let's play JNopo!

Yeah! It's time have fun playing *JNopo*!

Clone the https://github.com/OpenLiberty/sample-jakartaNoSQL-game[Git repository]:

[source, bash]
----
git clone https://github.com/OpenLiberty/sample-jakartaNoSQL-game.git

cd sample-jakartaNoSQL-game
----

Navigate to the `start` directory. This directory contains the starting project that we'll work through this blogpost.

[source, bash]
----
cd start
----

It's a Maven project using Maven Wrapper plugin, which means, you just need to have the *JDK 21* or later installed in your machine to build and/or run the application.

This project is ready to run with the https://openliberty.io/[Open Liberty] then you just need to perform the following command:

* For Mac or Linux:

+
[source, bash]
----
./mvnw liberty:dev
----

* For Windows:

+
[source, powershell]
----
mvnw.cmd liberty:dev
----

This will install all required dependencies and start the default server.

Now, if everything works, you can play the game by accessing the following URL address:

[source, curl]
----
http://localhost:9080/jakarta-nosql-game/
----

To play the game locally you just need to open two browsers tabs/windows pointing to the same URL address.

=== The Winner Ranking Challenge

This blog post will become more interesting: why not to challenge us to learn, create and improve our knowledge and practical software development skills, don't you? That's we're going to do: let's make JNopo provides a winner ranking!

This challenge is an amazing opportunity to learn and explore how to use Jakarta NoSQL and Jakarta Data to simplify NoSQL integration with Java applications.

To get a winner ranking, JNopo needs to persist the game matches results and then summarize the results composing the ranking. To expose this ranking, it's expected that the application provides a REST API like below:

[source, bash]
----
curl -X GET \
  -H 'Accept: application/json' \
  http://localhost:9080/jakarta-nosql-game/api/playoffs/ranking
----

The expected winner ranking structure should follow the JSON below:

[source, json]
----
{
  "data" : {
    "Max": 2,
    "Fabio": 1
  }
}
----

I said, it'll be interesting!

=== Implementing the Winner Ranking

The winner ranking requires a set of game matches results for its creation. To get that, we need to add to JNopo a persistence layer in order to capture and store the game match results.

==== Setting Up the Persistence Layer

Let's add the required dependencies to the project in order to be able to create the persistence layer. Our persistence layer will be implemented using Jakarta NoSQL and Jakarta Data specification. Both are Jakarta EE specifications, and they require an implementation at least to work. Eclipse JNoSQL is the implementation that we'll going to use.

Eclipse JNoSQL offers a Database API collection which covers these NoSQL flavours: Document, Key-value, Column and Graph databases. For now, Eclipse JNoSQL supports about https://www.jnosql.org/docs/supported_dbs.html[30 NoSQL databases].

For this challenge, let's develop the persistence layer to integrate with Document NoSQL databases type. Eclipse JNoSQL supports various Document NoSQL databases. You can find a list of supported databases, along with their configurations and dependencies, on the https://github.com/eclipse/jnosql-databases[GitHub repository].

==== Configuring Project Dependencies

Let's use MongoDB as Document NoSQL database default. Add the following Maven dependency into the `pom.xml` file of the project:

[source, xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-mongodb</artifactId>
  <version>1.1.0</version>
</dependency>
----

Once you have added the appropriate dependency, you need to configure the credentials for your Document NoSQL database. These credentials typically include details such as the database name, host, port, and any required authentication credentials. To configure MongoDB, you can find the supported credentials properties at the https://github.com/eclipse/jnosql-databases#mongodb[Eclipse JNoSQL MongoDB Database API Configuration].

==== Setting up Local NoSQL Databases

Install and manage databases locally requires additional efforts, and we will not cover it in this blog post. We chose to use Docker Compose as the tooling for managing containers locally. Take a look at https://docs.docker.com/compose/[Docker Compose Overview] to learn more about this tool.

Let's create a `docker-compose.yml` file into the project root directory and add the following content:

[source, yaml]
----
services:

  mongo:
    image: mongo
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: example
    ports:
      - 27017:27017

  mongo-express:
    image: mongo-express:1.0.0-alpha
    restart: always
    ports:
      - 8081:8081
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: root
      ME_CONFIG_MONGODB_ADMINPASSWORD: example
      ME_CONFIG_MONGODB_URL: mongodb://root:example@mongo:27017/
----

For convenience, the content above added a mongo-express service that will allow us to navigate and manage MongoDB data by a friendly web interface.

NOTE: Feel free to customize the declaration of the containers in the `docker-compose.yml` file. For example, the database data is saved inside the container image, which means that the data will be lost ever the containers are deleted.

Now, to start up the databases we just need to perform the following command:

[source, bash]
----
docker-compose up -d
----

After perform this command, you should be able to access the mongo-express at http://localhost:8081/ :

[.img_border_light]
image::/img/blog/mongo-express.png[Mongo Express, align="center" width=80%]


==== Defining Database Credentials

After to define the MongoDB database instance that we'll use, we are able to setting up Eclipse JNoSQL framework correctly.

Eclipse JNoSQL uses https://microprofile.io/specifications/microprofile-config/[Eclipse MicroProfile Config] to get the required configurations to establish the connection to the databases. We can define these properties on the `resources/META-INF/microprofile-config.properties` or via environment variables. To get more information about Eclipse MicroProfile Config, take a look at its https://microprofile.io/specifications/microprofile-config/[documentation].

According to the `docker-compose.yml` file that we have created previously, we can define the properties like below:

[source, properties]
----
jnosql.mongodb.host=localhost:27017
jnosql.mongodb.user=root
jnosql.mongodb.password=example
jnosql.mongodb.authentication.source=admin
----

==== Modeling Data with Jakarta NoSQL

Once we added the Eclipse JNoSQL dependencies, Jakarta NoSQL api comes together as a transient dependency to the project, allowing us to create the NoSQL entities we want.

Let's modeling the `GameMatch` entity. Such entity will represent each game match result.

As we said before, Eclipse JNoSQL allows us to use Java Records as entities, so, let's use this feature:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.nosql.Column;
import jakarta.nosql.Entity;
import jakarta.nosql.Id;

@Entity
public record GameMatch (
        @Id
        String id,

        @Column
        PlayerInfo playerA,

        @Column
        PlayerInfo playerB,

        @Column
        PlayerInfo winner,

        @Column
        PlayerInfo loser,

        @Column
        Boolean tied
){
}
----

To represent each player name and movement, lets modeling such data as `PlayerInfo` record class:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.nosql.Column;
import jakarta.nosql.Entity;

@Entity
public record PlayerInfo (

        @Column
        String name,

        @Column
        String movement
){
}

----

==== Data Storage and Retrieval with Jakarta Data

Now, in order to store and retrieve such entities from MongoDB database, it's required to create a component that will be responsible to do that. It's common to see developers using patterns like Data Access Object (DAO) to implement these components. That's not a problem at all, but we use to see them making the components closer to a specific vendor database semantics, raising a vendor lock-in situation.

Nowadays, in the cloud era where we pay as we go, switching between NoSQL solutions could be interesting to save resources and costs. Vendor lock-in would compromise this action, probably. Also, other consideration comes to the table when there's a need to switch databases, like: time spent on the change, the learning curve of a new API to use with this database, the code that will be lost, the persistence layer that needs to be replaced, etc. This is where the flexibility of Jakarta NoSQL shines.

Another interesting point is that DAO components tend to be closer to the database semantics than the business domain model language, requiring from developers a high cognitive load to connects the dots and fill the gaps between the technical codes and business necessities, once the code is not expressive enough, and doesn't fit with the ubiquitous language of the business. In this point, Jakarta Data comes to play!

Coming back to our challenge, let's create a repository component that will represents the play-offs:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.data.repository.DataRepository;
import jakarta.data.repository.Query;
import jakarta.data.repository.Repository;
import jakarta.data.repository.Save;

@Repository
public interface Playoffs extends DataRepository<GameMatch,String> {

    @Save
    GameMatch add(GameMatch gameMatch);

}
----

==== Capturing and Persisting Game Matches

With the entity and repository already created, it's needed to capture and persist the results of each game match. The next obvious question is: how could we capture the required game events?

It's a really good question! The answer is: https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0#events[the Events API provided by the Jakarta Context and Dependency Injection (CDI) specification]!

*JNopo* game is using https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0#events[CDI Events] to promote extension points, based on event publishing, to be used as needed. With that, we can implement an `@Observable` methods on any CDI bean to handle event objects.

See below the `GameState` interface. Objects that implements this interface will act as event objects:

[source, java]
----
package org.jakartaee.sample.game;

public sealed interface GameState permits
        WaitingPlayers,
        GameInvalid,
        GameAbandoned,
        GameReady,
        GameRunning,
        GameOver {
    String gameId();
}
----

The `GameState` interface is a sealed interface that defines all the supported game state. According to the sealed implementation, the event that we're interested is the `GameOver` state. Such class is a record class but, it's not just a simple record class that acts like a data transfer object (DTO), it has useful methods that returns important info like:

* The game identification;
* A tied attribute, to know if the game has ended as a tied one;
* The player A and its movement;
* The player B and its movement;
* The winner player and its movement, if the game has ended as a non-tied one.
* The loser player and its movement, if the game has ended as a non-tied one.

Next step: let`s create the `GameMatchCapturer` bean that will be responsible to capture the emitted `GameOver` state and then store the game match results into the database:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import jakarta.inject.Inject;
import org.jakartaee.sample.game.GameOver;

@ApplicationScoped
public class GameMatchCapturer {

    public void captureAndPersist(@Observes GameOver gameOver){
        // put the persistence logic here...
    }

}

----

At this point, let's instantiate a new `GameMatch` entity instance, populate it from `GameOver` data and then store it into the database by using the `Playoffs` component.

The required `Playoff` component, which is a repository implementation offered by Jakarta Data specification implementation, Eclipse JNoSQL, will be injected by CDI using the `@Inject` and `@Database(DOCUMENT)` annotations:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import jakarta.inject.Inject;
import org.eclipse.jnosql.mapping.Database;
import org.eclipse.jnosql.mapping.DatabaseType;
import org.jakartaee.sample.game.GameOver;

@ApplicationScoped
public class GameMatchCapturer {

    @Inject
    @Database(DatabaseType.DOCUMENT)
    Playoffs playoffs;

    public void captureAndPersist(@Observes GameOver gameOver){

            var gameMatch  = new GameMatch(
                    gameOver.gameId(),
                    PlayerInfo.of(gameOver.playerAInfo()),
                    PlayerInfo.of(gameOver.playerBInfo()),
                    gameOver.winnerInfo().map(PlayerInfo::of).orElse(PlayerInfo.NOBODY),
                    gameOver.winnerInfo().map(PlayerInfo::of).orElse(PlayerInfo.NOBODY),
                    gameOver.isTied()
            );

            playoffs.add(gameMatch);
    }

}
----

Now, let's get started the  https://openliberty.io/[Open Liberty] runtime to figure out if the game match results are being stored on the MongoDB:

* On Linux/Mac machines, perform the following command:
+
[source, bash]
----
./mvnw liberty:dev
----

* On Windows machines, perform the following command:
+
[source, powershell]
----
mvnw.cmd liberty:dev
----

After some game matches, we can confirm the persistence of the game matches into the database by looking at Mongo Express running on http://localhost:8081 :

[.img_border_light]
image::/img/blog/mongo-express-01.png[Mongo Express 01, align="center" width=80%]

[.img_border_light]
image::/img/blog/mongo-express-02.png[Mongo Express 02, align="center" width=80%]

[.img_border_light]
image::/img/blog/mongo-express-03.png[Mongo Express 03, align="center" width=80%]

[.img_border_light]
image::/img/blog/mongo-express-04.png[Mongo Express 04, align="center" width=80%]

Or, if you're a command-line practitioner, you can check the data by using the `mongosh` cli:

[source, bash]
----
docker exec -it finish-mongo-1 mongosh -u root -p example --authenticationDatabase admin jnopo
----

Once connected, feel free to perform mongo commands:

* Getting the number of stored documents:
+
[source, bash]
----
jnopo> db.GameMatch.countDocuments()
3
----

* Getting the stored documents list:
+
[source, bash]
----
jnopo> db.GameMatch.find()
[
  {
    _id: '2f42cf9e-f99c-44e5-bda8-7707da2579a3',
    tied: true,
    winner: { name: '', movement: '' },
    playerA: { name: 'Max', movement: 'ROCK' },
    playerB: { name: 'Ghost', movement: 'ROCK' },
    loser: { name: '', movement: '' }
  },
  {
    _id: 'c425815c-2aaf-4caa-a975-8e8089f0a0ce',
    tied: false,
    winner: { name: 'Max', movement: 'PAPER' },
    playerA: { name: 'Ghost', movement: 'ROCK' },
    playerB: { name: 'Max', movement: 'PAPER' },
    loser: { name: 'Max', movement: 'PAPER' }
  },
  {
    _id: 'bb7e7cd5-f8fe-4db1-9e90-44ecd433b4de',
    tied: false,
    winner: { name: 'Ghost', movement: 'ROCK' },
    playerA: { name: 'Ghost', movement: 'ROCK' },
    playerB: { name: 'Max', movement: 'SCISSORS' },
    loser: { name: 'Ghost', movement: 'ROCK' }
  }
]
----

Great! *JNopo* is storing the game match results as expected! It's time to create the winner ranking and then expose it though a restful endpoint http://localhost:9080/jakarta-nosql-game/api/playoffs/ranking .

==== Exposing the Winner Ranking

Collecting and storing the game matches results is a great step to make us able to implement the winner ranking feature.

Let's implement the `Ranking` class to represent any ranking on the *JNopo* application.

The `Ranking` creation requires the data from the `Playoffs` component. In order to avoid to create a new layer to keep the logic of the ranking creation, I decided to use a simple approach: a simple static factory method on the `Ranking` class itself.

Firstly, `Playoffs` needs to provide a method to retrieve the non-tied game results:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.data.repository.DataRepository;
import jakarta.data.repository.Query;
import jakarta.data.repository.Repository;
import jakarta.data.repository.Save;

import java.util.stream.Stream;

@Repository
public interface Playoffs extends DataRepository<GameMatch,String> {

    @Save
    GameMatch add(GameMatch gameMatch);

    @Query("select * from GameMatch where tied=false")
    Stream<GameMatch> nonTiedGameMatches();

}
----

NOTE: *JNoSQL* offers a simple query language pretty similar to SQL but be sure that it's not a complete SQL implementation, which means, some aggregation and functions will be not available.

Regarding the aggregation process that evolves the ranking logic creation, we use to see developers delegating this aggregation logic to the DBMS and, depending on the persistence mechanism, it should be the best approach. By now, the grouping projection functions like we have with Jakarta Persistence is not available on the Jakarta NoSQL for now, but, in the future, such capability could be available as well.

In order to keep our implementation free of vendor lock-in, I decided to implement the aggregation process by using the Stream API. I added comments on the code to help you to understand the implemented logic.

[source, java]
----
package org.jakartaee.sample.model;

import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Collectors;

public record Ranking(Map<String, Integer> data) {
    public static Ranking winnerRanking(Playoffs playoffs) {

        var data =
                // getting the game matches that are not tied
                playoffs.nonTiedGameMatches()
                // grouping by winner's name and summarize by game match
                .collect(Collectors.groupingBy(
                        g -> g.winner().name(),
                        Collectors.collectingAndThen(Collectors.toList(), Collection::size)))
                .entrySet()
                .stream()
                // sorting the results by number of game match in descending order
                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
                // collecting as a LinkedHashMap to keep the sorted items
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        Map.Entry::getValue,
                        (e1, e2) -> e1, LinkedHashMap::new));

        return new Ranking(data);
    }
}
----

Now, let make this ranking be accessible by our model. As the ranking needs the data from `Playoffs` component, why not to put this ranking creation on the `Playoffs` interface? That's we're going to do! It is possible since the Java 8:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.data.repository.DataRepository;
import jakarta.data.repository.Query;
import jakarta.data.repository.Repository;
import jakarta.data.repository.Save;

import java.util.stream.Stream;

@Repository
public interface Playoffs extends DataRepository<GameMatch,String> {

    @Save
    GameMatch add(GameMatch gameMatch);

    @Query("select * from GameMatch where tied=false")
    Stream<GameMatch> nonTiedGameMatches();

    default Ranking winnerRanking(){
       return Ranking.winnerRanking(this);
    }
}
----

It looks like we're getting closer to our goal!

Following the challenge requirements, let's create the resource component that will expose the winner ranking.

Firstly, let's create the `RestApplication` class to define the url dedicated to restful endpoints:
[source, java]
----
package org.jakartaee.sample.resources;

import jakarta.ws.rs.ApplicationPath;
import jakarta.ws.rs.core.Application;

@ApplicationPath("/api")
public class RestApplication extends Application {

}
----

Now, any url under `/api` will be handled by the Jakarta Restful Webservices implementation available in our runtime environment.

Next step: let's implement the `PlayoffsResource` resource. This component will expose an HTTP GET endpoint for the `/api/playoffs/ranking` url:

[source, java]
----
package org.jakartaee.sample.resources;

import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import org.eclipse.jnosql.mapping.Database;
import org.eclipse.jnosql.mapping.DatabaseType;
import org.jakartaee.sample.model.Playoffs;
import org.jakartaee.sample.model.Ranking;

@Path("/playoffs")
@Consumes({MediaType.APPLICATION_JSON})
@Produces({MediaType.APPLICATION_JSON})
public class PlayoffsResource {

    @Inject
    @Database(DatabaseType.DOCUMENT)
    Playoffs playoffs;

    @GET
    @Path("/ranking")
    public Ranking getRanking() {
        return playoffs.winnerRanking();
    }
}
----

It's time to test everything! Let's restart the https://openliberty.io/[Open Liberty] runtime:

* On Linux/Mac machines, perform the following command:
+
[source, bash]
----
./mvnw liberty:dev
----

* On Windows machines, perform the following command:
+
[source, powershell]
----
mvnw.cmd liberty:dev
----

https://openliberty.io/[Open Liberty]  provides us an amazing tooling to help during the development of Jakarta EE / MicroProfile applications. When the dev mode is running, we can use some HTTP addresses to test and explore the capabilities offered by this amazing Jakarta EE/MicroProfile runtime:

[source, console]
----
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/openapi/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/health/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/jwt/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/metrics/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/openapi/ui/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/ibm/api/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/jakarta-nosql-game/
----

In this blog post, let's focus on two of these url:

* http://localhost:9080/jakarta-nosql-game/ : it's the url of the application that we can use locally;

* http://localhost:9080/openapi/ui/ : it's the Swagger UI interface that  https://openliberty.io/[Open Liberty]  offers out-of-the-box, facilitating the rest endpoint testing via browser.

[.img_border_light]
image::/img/blog/swagger-ui-01.png[Swagger UI 01, align="center" width=80%]

[.img_border_light]
image::/img/blog/swagger-ui-02.png[Swagger UI 02, align="center" width=80%]


If you're a command-line practitioner, you can check the data by using the `curl` command:

[source, bash]
----
curl -X 'GET' \
  'http://localhost:9080/jakarta-nosql-game/api/playoffs/ranking' \
  -H 'accept: application/json' | jq
----

[source, json]
----
{
  "data": {
    "Max": 3,
    "Ghost": 1
  }
}
----

Congratulations if you made it this far!

Now, *JNopo* is providing a winner ranking!

If you're interesting to take a look on the finished project code version developed during this challenge, clone this https://github.com/OpenLiberty/sample-jakartaNoSQL-game[Git repository] and then navigate to the `winner-ranking-challenge` directory.

[source, bash]
----
git clone https://github.com/OpenLiberty/sample-jakartaNoSQL-game.git
cd sample-jakartaNoSQL-game
cd winner-ranking-challenge
----


=== Switching NoSQL Databases with Ease

Nowadays, in the cloud era, switching between NoSQL solutions could be interesting to save resources and costs, but it could be a nightmare, specially if we're highly coupled to a particular vendor. It will cause some changes that will make this approach very expensive, like: time spent on the change, the learning curve of a new API to use with this database, the code that will be lost, the persistence layer that needs to be replaced, etc.

This is where the flexibility of Jakarta NoSQL with an implementation like Eclipse JNoSQL together shines.

To explore this capability, let's suppose that it's needed to change the Document NoSQL database used by the *JNopo* application, MongoDB, to another Document NoSQL database for save money purposes, e.g. Couchbase.

Just a few changes, we'll be able to archive this goal easily.

==== Configuring Eclipse JNoSQL dependencies for Couchbase

In the `pom.xml` file, add the following dependency:

[source, xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-couchbase</artifactId>
  <version>1.1.0</version>
</dependency>
----


==== Configuring a Local Couchbase Cluster

Add the following content to the `docker-compose.yml` file:

[source, yaml]
----
  couchbase-db:
    image: couchbase
    container_name: couchbase-db
    ports:
      - "8091-8097:8091-8097"
      - "9123:9123"
      - "11207:11207"
      - "11210:11210"
      - "11280:11280"
      - "18091-18097:18091-18097"
----

After to apply these changes, initialize the container by executing the following command:

[source, bash]
----
docker-compose up -d
----

Now, let's configure the Couchbase cluster for this study scenario:

. With the Couchbase container started, go to: http://localhost:8091/ui/index.html
. Select the "Configure New Cluster" option
+
[.img_border_light]
image::/img/blog/couchbase-01.png[Couchbase 01, align="center" width=80%]
. Defines a name for the cluster name
. Set `root` to "Administrator" username
. Set `123456` as "Password"
+
[.img_border_light]
image::/img/blog/couchbase-02.png[Couchbase 02, align="center" width=80%]
. Check “I accept the terms and conditions” and click the “Finish With Defaults” button
+
[.img_border_light]
image::/img/blog/couchbase-03.png[Couchbase 03, align="center" width=80%]
. Go to the "Buckets" section
. Create a `jnopo` Bucket by clicking on the "Add Bucket" option
+
[.img_border_light]
image::/img/blog/couchbase-04.png[Couchbase 04, align="center" width=80%]
. Click on "Scopes & Collections" and then click on "Add Collection"
. Enter `GameMatch` as the collection name and click the "Save" button to complete your creation
+
[.img_border_light]
image::/img/blog/couchbase-05.png[Couchbase 05, align="center" width=80%]
. Now, in the "Query" section, run this command https://www.couchbase.com/products/n1ql/[N1QL] to create the primary index for the `GameMatch` collection:
+
[source, n1ql]
----
CREATE PRIMARY INDEX primaryGameMatch ON jnopo._default.GameMatch
----
+
[.img_border_light]
image::/img/blog/couchbase-06.png[Couchbase 06, align="center" width=80%]

With a Couchbase cluster running, we just need to set up Eclipse JNoSQL to connect to it.

Apply the following changes into the `resources/META-INF/microprofile-config.properties` file:

[source, properties]
----
## Couchbase
jnosql.couchbase.host=couchbase://localhost
jnosql.couchbase.user=root
jnosql.couchbase.password=123456
jnosql.document.provider=org.eclipse.jnosql.databases.couchbase.communication.CouchbaseDocumentConfiguration
----

The `jnosql.document.provider` property is required in this context because we have more than one Eclipse JNoSQL Database API for Document NoSQL implementations. Learn more about these configurations about Eclipse JNoSQL Database API for Couchbase at this https://github.com/eclipse/jnosql-databases/tree/main?tab=readme-ov-file#configuration-2[Git repository].

That's all! Let's restart the https://openliberty.io/[Open Liberty] runtime in order to be able to make sure that everything is running smoothly:

* On Linux/Mac machines, perform the following command:
+
[source, bash]
----
./mvnw liberty:dev
----

* On Windows machines, perform the following command:
+
[source, powershell]
----
mvnw.cmd liberty:dev
----

After some game matches, here are the evidences:

[.img_border_light]
image::/img/blog/couchbase-verification-01.png[Couchbase Verification 01, align="center" width=80%]
[.img_border_light]
image::/img/blog/couchbase-verification-02.png[Couchbase Verification 02, align="center" width=80%]

If you're interesting to take a look on the finished project code version developed during this challenge, clone this https://github.com/OpenLiberty/sample-jakartaNoSQL-game[Git repository] and navigate to the `database-switching-challenge` directory.

[source, bash]
----
git clone https://github.com/OpenLiberty/sample-jakartaNoSQL-game.git
cd sample-jakartaNoSQL-game
cd database-switching-challenge
----

== Key Takeaways

These challenges were an amazing opportunities to learn not just about Jakarta NoSQL and Jakarta Data to simplify the NoSQL integration with Java applications but be exploring new development approaches using interesting Java features.

What we got by doing these challenges:

* A practical example that uses:
** Sealed classes (final feature since Java 17)
** Pattern Matching for Instanceof (final feature since Java 16)
** Pattern Matching for Switch (final feature since Java 21);


What we learned from them:

* How to configure Eclipse JNoSQL to allow us to work with Jakarta NoSQL and Jakarta Data in a Jakarta EE / MicroProfile project;
* How to work with Jakarta NoSQL to create entities pretty similar to Jakarta Persistence approach;
* How to create repositories with Jakarta Data, the newest Jakarta EE Specification that will be available in the Jakarta EE 11;
* How to switch between NoSQL database from different vendors, in our example: switching MongoDB to Couchbase;

== Next Steps: Continuing the Journey

Congratulations on getting this far!

To see more sample projects, take a look at the official Eclipse JNoSQL samples repositories:

- https://github.com/jnosql/demos-se
- https://github.com/JNOSQL/demos-ee


To learn more about Eclipse JNoSQL, take a look at these official repositories:

- https://github.com/eclipse/jnosql
- https://github.com/eclipse/jnosql-databases
- https://github.com/eclipse/jnosql-extensions

if you're an expert on some NoSQL database that Eclipse JNoSQL doesn't support, feel free to open an issue or a PR on the project repositories mentioned above.

Except for the NoSQL solutions mentioned like MongoDB and Couchbase, all the technology used in this blog post are open-source, so, what do you think about contributing to these projects?

If you don't know how to get started to contribute, take a look at this https://www.youtube.com/live/7qhHOOoZEBU?feature=share[Coffee.withJava("Contribute to JNoSQL") Youtube Series], or if you prefer, feel free to contact me!

Contributing to these projects is not just with codes, you could help a lot by promoting and speaking about them wherever you go!

Contributing to open-source is a great way to boost your career, and improve your skills to become an effective developer and relevant in the market! Think about that!

== Special Thanks

I'm bursting with gratitude and would love to give a big shout-out to my incredible Java community friends for their unwavering support throughout my journey. A special round of applause for:

- Otavio Santana, you're not just a mentor but a guiding star in my open-source journey. Your mentorship have opened doors for me to become an active open-source contributor and a proud Eclipse Foundation committer. Thank you for being such a monumental part of my journey. Also, thanks for your insightful reviews of the codes featured in this blog post.

- Karina Varela, your keen eye for detail and your generosity in sharing your knowledge have enriched this content beyond measure. Your thoughtful reviews have made this content not just better, but truly curated and relevant. I'm so grateful for your contribution.

- Fabio Franco, you were the catalyst for this wonderful opportunity, connecting me with the fantastic OpenLiberty team and offering your support throughout the publishing process of this blog post. Your belief in me and your encouragement have been invaluable. Thank you for making this possible.

- And to the OpenLiberty team, thank you for opening your doors and allowing me the privilege to share and post this content that I've thoroughly enjoyed working on. Thanks for this opportunity.

To each of you, your support means a lot to me, and I'm deeply thankful.

== References and Further Reading

* Official documentation:
** https://jnosql.org[Eclipse JNoSQL website]
** https://jakarta.ee/specifications/[Jakarta EE Specifications]

* Articles:
** https://dzone.com/articles/jakarta-nosql-100-b5-how-to-make-your-life-easier[Jakarta NoSQL 1.0.0-b5: How To Make Your Life Easier Around Enterprise Java and NoSQL Databases by Otavio Santana]
** https://dzone.com/articles/eclipse-jnosql-100-streamlining-java-and-nosql-int[Eclipse JNoSQL 1.0.0: Streamlining Java and NoSQL Integration With New Features and Bug Fixes by Otavio Santana]
** https://dzone.com/articles/mastering-java-persistence-best-practices-for-clou[Mastering Java Persistence: Best Practices for Cloud-Native Applications and Modernization by Otavio Santana]
** https://dzone.com/articles/eclipse-jnosql-102-empowering-java-with-nosql-data[Eclipse JNoSQL 1.0.2: Empowering Java With NoSQL Database Flexibility by Otavio Santana]
** https://blogs.oracle.com/nosql/post/getting-started-accessing-oracle-nosql-database-using-jakarta-nosql[Getting Started - Accessing Oracle NoSQL Database using Jakarta NoSQL by Dario VEGA]
** https://dzone.com/articles/exploring-the-new-eclipse-jnosql-version-110-a-div[Exploring the New Eclipse JNoSQL Version 1.1.0: A Dive Into Oracle NoSQL by Otavio Santana]
** https://eldermoraes.com/how-to-create-cdi-events/[How to create CDI Events by Elder Moraes]
** https://blogs.oracle.com/javamagazine/post/jakarta-data-mysql[Simplifying data access with MySQL and Jakarta Data by Ivar Grimstad]
** https://dzone.com/articles/introduction-to-nosql-database-1[Introduction to NoSQL Database by Rama Krishna Panguluri];

* Books:
** https://www.amazon.com/Persistence-Best-Practices-Java-Applications/dp/1837631271/[Persistence Best Practices for Java Applications by Otavio Santana and Karina Varela]
** https://a.co/d/4dlvHQj[NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence by Pramod Sadalage and Martin Fowler]

