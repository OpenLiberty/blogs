---
layout: post
title: "Simplifying NoSQL Database Integration with Jakarta NoSQL"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/dearrudam
author_github: https://github.com/dearrudam
seo-title: TITLE - OpenLiberty.io
seo-description: DESCRIPTION
blog_description: "DESCRIPTION"
open-graph-image: https://openliberty.io/img/twitter_card.jpg
open-graph-image-alt: Open Liberty Logo
---
= Simplifying NoSQL Database Integration with Jakarta NoSQL
Maximillian Arruda <https://github.com/dearrudam>
:imagesdir: /
:url-prefix:
:url-about: /


// // // // // // // //
// In the preceding section:
// Do not insert any blank lines between any of the lines.
//
// "open-graph-image" is set to OL logo. Whenever possible update this to a more appropriate/specific image (For example if present a image that is being used in the post). However, it
// can be left empty which will set it to the default
//
// "open-graph-image-alt" is a description of what is in the image (not a caption). When changing "open-graph-image" to
// a custom picture, you must provide a custom string for "open-graph-image-alt".
//
// Replace DESCRIPTION with a short summary (~60 words) of the release (a more succinct version of the first paragraph of the post).
//
// If adding image into the post add :
// -------------------------
// [.img_border_light]
// image::img/blog/FILE_NAME[IMAGE CAPTION ,width=70%,align="center"]
// -------------------------
// "[.img_border_light]" = This adds a faint grey border around the image to make its edges sharper. Use it around screenshots but not
// around diagrams. Then double check how it looks.
// There is also a "[.img_border_dark]" class which tends to work best with screenshots that are taken on dark backgrounds.
// Change "FILE_NAME" to the name of the image file. Also make sure to put the image into the right folder which is: img/blog
// change the "IMAGE CAPTION" to a couple words of what the image is
// // // // // // // //

Nowadays, it's normal to see cloud-native solutions dealing with a huge amount of information. In this scenario, the NoSQL databases are getting a huge relevant position, but dealing with many NoSQL solutions from many different vendors is very difficult.

In terms of dealing with relational databases, there's no doubt that JPA specification is a well-established API in the Java world, but what if there's a well-defined way, pretty similar to JPA, to work with NoSQL with Java?

In this blogpost, let's discuss and learn why Jakarta NoSQL can make easier the developer's life regarding the Java NoSQL database integration.


== NoSQL Overview

For some, NoSQL stands for "Not Only SQL", for others stands for "Non-SQL" or "Not Relational" but one thing we may agree on: NoSQL databases are different from SQL databases.

Unlike the traditional SQL databases that use tabular relations to store and retrieve data with predefined schemas, NoSQL Databases provide mechanisms for retrieving and storing unstructured and semi-structured data (non-relational). Compared to relational databases, NoSQL databases have better performance and high levels of availability and scalability, which means, they are designed to scale horizontally by distributing data across many servers, making them well-suited for handling large and growing datasets. As they are becoming more popular in several industries, such as finance and streaming, the number of users and database vendors is growing as well.

There are many NoSQL databases types, each one is designed to handle a specific set of workloads and data modeling needs.

== Different types of NoSQL Database

Many NoSQL databases types exist, but let's focus on the most famous types: Key-Value, Document, Column, and Graph databases;

=== Key-Value Databases

These are the simplest storage types between the NoSQL databases. Key-value NoSQL databases store data as a collection of key-value pairs, making them ideal for high-speed data retrieval by using keys. This database type has a structure that resembles a `java.util.Map` API from the Java language where values are mapped to keys. Key-value databases are often used for caching, session management, and message queues.

[.img_border_light]
image::/img/blog/key-value-nosql.png[Key-value database type,align="center" width=25%,height=25%]


Currently on the market, there are many vendors that provide solutions for this NoSQL database type. Some of them are: *Amazon DynamoDB*, *Redis*, *Hazelcast*, *Memcached*, among others. The latter three mentioned here are open source technologies.

=== Document Databases

The Document NoSQL databases are designed to store, retrieve, and manage documents with a minimally defined structure, such as the XML and JSON formats. A document without a predefined structure, in other words, is a data model that may be composed of numerous fields with different kinds of data, including documents inside other documents. For practitioners of Domain-Driven Development (DDD), this data structure may be handled as aggregates managing their derived entities in a hierarchical structure. Document databases are well-suited for managing unstructured data, such as user profiles, product catalogs, or content management systems.

[.img_border_light]
image::/img/blog/document-nosql.png[Document database type,align="center" width=25%,height=25%]

There are many vendors that provides solutions for this NoSQL database type on the market. Some of them are: *MongoDB*, *Couchbase*, *Elastic*, *Oracle NoSQL Database*, among others.

=== Column Databases

The Column NoSQL databases (also known as column-oriented or wide-column databases) store data as columns instead of rows as usual in the traditional relational databases world, making them ideal for handling large amounts of data and complex queries once compared with other NoSQL database types. These databases are designed and optimized for storing large amounts of structured, semi-structured, and unstructured data with a flexible schema, supporting high levels of concurrency and scalability. Wide-column databases are often used for analytics, content management, and data warehousing.

[.img_border_light]
image::/img/blog/column-nosql.png[Column database type,align="center" width=25%,height=25%]

Examples of Column databases on the market include *Apache HBase*, *Apache Cassandra*, *Scylla*, *Azure Cosmos DB*, and many others. The first two mentioned here are open source technologies.

=== Graph Databases

The Graph NoSQL database type is designed and optimized for storing and querying data with complex relationships. In this approach, data is managed as a graph where entities can be represented as node and edges, making them well-suited for managing complex relationship and hierarchies. The graph data resembles the graph of objects in the Oriented-Object programming paradigm. Graph NoSQL database solutions can fit well in scenarios that require fast querying of highly interconnected data, such as social networks, recommendation engines, and fraud detection systems.

[.img_border_light]
image::/img/blog/graph-nosql.png[Graph database type,align="center" width=25%,height=25%]

There are several graph database engines of many vendors to choose from, including *Neo4J*, *Arango DB*, *OrientDB*, *JanusGraph*, among others. The last one mentioned is open source technologies.

=== NoSQL integration challenges

Nowadays, depending on the requirements of the solutions that need to be delivered, integrating into these NoSQL databases will be inevitable, so we'll need to be able to deal with many NoSQL solutions from many different vendors. Having said that, many challenges raise to us, like:

* The high cognitive load necessary when choosing a NoSQL database for their solutions;
* The Learning curve of the database APIs of the chosen NoSQL databases;
* The time spent on the changes to the existent codebase;
* The possibility to make complex the onboarding of new coming developers to the team;

Furthermore, today in the cloud era where we pay as we use, we are always looking for save resources and costs, which means, the possibility to switch out a database becomes true. In addition to the challenges above, the solution that integrates with these NoSQL solutions needs to be able to keep a concise business logic isolation from the persistence layer because probably such a layer will be changed or replaced.

According to https://db-engines.com/en/ranking[DB-Engines Ranking], an initiative from DB-Engines website that lists DBMS ranked by popularity, on February 2024 we can figure out that there are over **180 non-relational/NoSQL databases on the market**. In the chart below we can see the ranking of database engines per database category:

[.img_border_light] 
image::/img/blog/db-engine-ranking-2024-02.png["Number of engines per category, February 2024",width=70%,align="center"]

In order to solve these mentioned challenges, let's take a look at the past not so far away, we can see a similar challenge involving Relational database and Java integration. The JDBC (Java Database connectivity) was created to standardize the way Java integrates with Relational databases, and then, to get closer to the OOP paradigm using the ORM pattern, Jakarta Persistence specification comes to facilitate the work with many Relational databases engines and vendors.

Okay, based on this information about the solution using Jakarta Persistence, wouldn't it be interesting to have a similar API to work with NoSQL?

Say hello to Jakarta NoSQL and Jakarta Data! Both came to simplify the NoSQL integration with many vendors, making data retrieval and manipulation more intuitive and developer-friendly.

== Jakarta NoSQL

Jakarta NoSQL is a Jakarta EE specification designed to easily integrate Java and NoSQL databases. It uses common annotations and specific APIs for the following NoSQL database types: key-value, column, and document databases.

== Jakarta Data

Jakarta Data is a Jakarta EE specification that provides a unified API for simplified data access across different types of databases, including both relational and NoSQL databases. This specification achieves this by introducing concepts like Repositories and custom query methods, making data retrieval and manipulation more intuitive and developer-friendly.

[NOTE]
Jakarta Data will be included in Jakarta EE 11 - https://jakarta.ee/specifications/data/1.0/

== Eclipse JNoSQL - A Reference Implementation

A Jakarta EE Specification doesn't solve the problem by themselves alone, it's necessary an implementation.

Each Jakarta EE Specification use to have at least one implementation. Having one implementation means that the specification is implementable, opening the opportunity for companies and community to provide their own implementation, powering the Jakarta EE users with various and powerful tooling.

Example of reference implementations (RI):

* Hibernate for Jakarta Persistence 3.1 specification;
* Jersey for Jakarta RESTFul Web Services 3.1 specification;
* Glassfish for Jakarta Servlet 6.0 specification;
* Weld for Jakarta Context And Dependency Injection (CDI) 4.0 specification;
* and so on...

*Eclipse JNoSQL* is a compatible implementation of the *Jakarta NoSQL* and *Jakarta Data* specification, a framework that streamlines the integration of Java applications with NoSQL databases. It uses the power of the Jakarta Contexts and Dependency Injection (CDI) specification as an engine, making it compatible with both Jakarta EE vendors and Eclipse MicroProfile.

Currently, the Jakarta NoSQL doesn't define an API for Graph database types but Eclipse JNoSQL provides a Graph template to explore the specific behavior of this NoSQL type by using Apache TinkerPop as a communication layer. In summary, Eclipse JNoSQL covers four NoSQL database types: key-value, column, document and graph databases.

For now, Eclipse JNoSQL supports about https://www.jnosql.org/docs/supported_dbs.html[30 NoSQL databases].

=== Motivation

In the snipped codes below we can see a typical behavior among Document NoSQL databases: a document creation and adding a property into the created document:

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/mongodb.png[MongoDB ,align="left" width=25%,height=25%]
[source, java]
----
Document document = new Document();
document.append(name, value);
----
****

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/ArangoDB.png[Arango DB,align="left" width=25%,height=25%]
[source, java]
----
BaseDocument baseDocument = new BaseDocument();
baseDocument.addAttribute(name, value);
----
****

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/couchbase.svg[Couchbase,align="left" width=25%,height=25%]
[source, java]
----
JsonObject jsonObject = JsonObject.create();
jsonObject.put(name, value);
----
****

[.img_border_light]
****
image::https://jnosql.github.io/img/logos/orientdb.png[Orient Project,align="left" width=25%,height=25%]
[source, java]
----
ODocument document = new ODocument("collection");
document.field(name, value);
----
****

Eclipse JNoSQL provides a common API that allows to use several database types without vendor lock-in providing a low cognitive load to learn a new API. For example, on the Document API, it's possible to switch between MongoDB and ArangoDB as needed by using CoC (Convention Over Configuration).

[.img_border_light]
****
image::https://jnosql.github.io/images/home_logo.png[Orient Project,align="left" width=25%,height=25%]
[source, java]
----
DocumentEntity entity = DocumentEntity.of("collection");
entity.add(name, value);
----
****

Also, we can explore the Jakarta NoSQL annotations here:

[source, java]
----
import jakarta.nosql.Entity;
import jakarta.nosql.Id;
import jakarta.nosql.Column;

@Entity
public class Book {

    @Id
    private String isbn;

    @Column
    private String title;

    @Column
    private String author;

    @Convert(YearConverter.class)
    @Column
    private Year year;

}
----

If the project is using Java 17 or above, Eclipse JNoSQL allows us to use Java Records as entities:

[source, java]
----
import jakarta.nosql.Entity;
import jakarta.nosql.Id;
import jakarta.nosql.Column;

@Entity
public record Book(@Id String isbn,
                   @Column("title") String title,
                   @Column("author") String author,
                   @Convert(YearConverter.class) @Column("year") Year year,
                   @Column("edition") int edition) {

}

----

Last but not least, Eclipse JNoSQL as a Jakarta Data implementation allows us to create repositories, offering a feature based on the Domain-Driven Development (DDD) Repository pattern, helping developers to bring the code near to the business (domain centric) instead of the database semantics.

[source,java]
----
import jakarta.data.page.Page;
import jakarta.data.page.Pageable;
import jakarta.data.repository.Delete;
import jakarta.data.repository.Repository;
import jakarta.data.repository.PageableRepository;
import jakarta.data.repository.Query;
import jakarta.data.repository.Param;
import jakarta.data.repository.Save;

@Repository
public interface Garage extends PageableRepository<Car,String>{

    @Save
    Car park(Car car);

    @Delete
    Car unPark(Car car);

    @Query("select * from Car where driver.name = @name")
    Set<Car> findByDriver(@Param("name") String name);

    Page<Car> findByColor(Color color, Pageable pageable);

}
----

=== Eclipse JNoSQL Goals

Beyond being a Jakarta NoSQL and Jakarta Data implementation, such framework intents to reaching out these goals:

* Increase productivity performing common NoSQL operations
* Use of Convention Over Configuration
* Rich Object Mapping integrated with Contexts and Dependency Injection (CDI)
* Java-based Query and Fluent-API
* Persistence lifecycle events
* Low-level mapping using Standard NoSQL APIs
* Specific template API to each NoSQL category
* Annotation-oriented using JPA-like naming when it makes sense
* Extensible to explore the particular behavior of a NoSQL database
* Explore the popularity of Apache TinkerPop in Graph API

After getting an overview about the Jakarta NoSQL, Jakarta Data, and the Eclipse JNoSQL, let's explore on a hands-on approach how we could use and forest these features in an interesting project, managing and querying data from NoSQL databases and switching between NoSQL databases as needed.

== Meeting the JNopo game

*JNopo* game is a Java version of the famous the _Rock, Paper, and Scissors_ game. This game consists of a battle of two players where each one chooses a movement between rock, paper, or scissors. To illustrate the game logic, let's suppose that a _Player A_ will play with a _Player B_ and, in this case:

* If _Player A_ chooses _ROCK_ and _Player B_ chooses _SCISSORS_ then _Player A_ wins the game.
* If _Player A_ chooses _PAPER_ and _Player B_ chooses _ROCK_ then _Player A_ wins the game.
* If _Player A_ chooses _SCISSORS_ and _Player B_ chooses _PAPER_ then _Player A_ wins the game.
* If _Player A_ and _Player B_ choose the same movement then no one wins, and a tied game happens.

In the sequence diagram below we can illustrate the default behavior of the JNopo game:

[.img_border_light]
image::/img/blog/jnopo-sequence-diagram-without-persistence.gif[JNopo Sequence Diagram, align="center" width=60%]

*JNopo* is a game implemented using Jakarta EE Specifications, which means, it's compatible with Jakarta EE and MicroProfile runtimes, and in our case we're using https://openliberty.io/[Open Liberty] 23.0.0.10.

The architecture for this application is composed by two components:

* The web page where the players interact to the game;

* The back-end where the game matches are managed;

In the image below we can see the system design of the JNopo game:

[.img_border_light]
image::/img/blog/jnopo-architecture-without-persistence.png[JNopo Architecture Diagram, align="center" width=60%]

== It's time to have fun! Let's play the JNopo game!

Yeah! It's time have fun playing *JNopo*!

Clone the https://github.com/OpenLiberty/sample-jakartaNoSQL-game[Git repository]:

[source, bash]
----
git clone https://github.com/OpenLiberty/sample-jakartaNoSQL-game.git

cd sample-jakartaNoSQL-game
----

Navigate to the `start` directory. This directory contains the starting project that we'll work through this blogpost.

[source, bash]
----
cd start
----

It's a Maven project using Maven Wrapper plugin, which means, you just need to have the *JDK 21* installed in your machine to build and/or run the application.

This project is ready to run with the https://openliberty.io/[Open Liberty] then you just need to perform the following command:

* For Mac or Linux:

+
[source, bash]
----
./mvnw liberty:dev
----

* For Windows:

+
[source, powershell]
----
mvnw.cmd liberty:dev
----

This will install all required dependencies and start the default server.

Now, if everything works, you can play the game by accessing the following URL address:

[source, curl]
----
http://localhost:9080/jakarta-nosql-game/
----

To play the game locally you just need to open two browsers tabs/windows pointing to the same URL address.

== Challenge time: Winner ranking

This blog post will become more interesting: why not to challenge us to learn, create and improve our knowledge and practical software development skills, don't you? That's we're going to do: let's make JNopo provides a winner ranking!

This challenge is an amazing opportunity to learn and explore how to use Jakarta NoSQL and Jakarta Data to simplify NoSQL integration with Java applications.

To get a winner ranking, JNopo needs to persist the game matches results and then summarize the results composing the ranking. To expose this ranking, it's expected that the application provides a REST API like below:

[source, bash]
----
curl -X GET \
  -H 'Accept: application/json' \
  http://localhost:9080/jakarta-nosql-game/api/playoffs/ranking
----

The expected winner ranking structure should follow the JSON below:

[source, json]
----
{
  "data" : {
    "Max": 2,
    "Fabio": 1
  }
}
----

I said, it'll be interesting!

=== Implementing the Winner Ranking

The winner ranking requires a set of game matches results for its creation. To get that, we need to add to JNopo a persistence layer in order to capture and store the game match results.

=== Implementing the persistence layer

Let's add the required dependencies to the project in order to be able to create the persistence layer. Our persistence layer will be implemented using Jakarta NoSQL and Jakarta Data specification. Both are Jakarta EE specifications, and they require an implementation at least to work. Eclipse JNoSQL is the implementation that we'll going to use.

Eclipse JNoSQL offers a Database API collection which covers these NoSQL flavours: Document, Key-value, Column and Graph databases. For now, Eclipse JNoSQL supports about https://www.jnosql.org/docs/supported_dbs.html[30 NoSQL databases].

For this challenge, let's develop the persistence layer to integrate with Document NoSQL databases type. Eclipse JNoSQL supports various Document NoSQL databases. You can find a list of supported databases, along with their configurations and dependencies, on the https://github.com/eclipse/jnosql-databases[GitHub repository].

==== Setup dependencies

Let's use MongoDB as Document NoSQL database default. Add the following Maven dependency into the `pom.xml` file of the project:

[source, xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-mongodb</artifactId>
  <version>1.1.0</version>
</dependency>
----

Once you have added the appropriate dependency, you need to configure the credentials for your Document NoSQL database. These credentials typically include details such as the database name, host, port, and any required authentication credentials. To configure MongoDB, you can find the supported credentials properties at the https://github.com/eclipse/jnosql-databases#mongodb[Eclipse JNoSQL MongoDB Database API Configuration].

==== Setting up the NoSQL databases locally

Install and manage databases locally requires additional efforts, and we will not cover it in this blog post. We chose to use Docker Compose as the tooling for managing containers locally. Take a look at https://docs.docker.com/compose/[Docker Compose Overview] to learn more about this tool.

Let's create a `docker-compose.yml` file into the project root directory and add the following content:

[source, yaml]
----
services:

  mongo:
    image: mongo
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: example
    ports:
      - 27017:27017

  mongo-express:
    image: mongo-express:1.0.0-alpha
    restart: always
    ports:
      - 8081:8081
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: root
      ME_CONFIG_MONGODB_ADMINPASSWORD: example
      ME_CONFIG_MONGODB_URL: mongodb://root:example@mongo:27017/
----

For convenience, the content above added a mongo-express service that will allow us to navigate and manage MongoDB data by a friendly web interface.

NOTE: Feel free to customize the declaration of the containers in the `docker-compose.yml` file. For example, the database data is saved inside the container image, which means that the data will be lost ever the containers are deleted.

Now, to start up the databases we just need to perform the following command:

[source, bash]
----
docker-compose up -d
----

After perform this command, you should be able to access the mongo-express at http://localhost:8081/ :

[.img_border_light]
image::/img/blog/mongo-express.png[Mongo Express, align="center" width=80%]


==== Configuring Database Credentials

After to define the MongoDB database instance that we'll use, we are able to setting up Eclipse JNoSQL framework correctly.

Eclipse JNoSQL uses https://microprofile.io/specifications/microprofile-config/[Eclipse MicroProfile Config] to get the required configurations to establish the connection to the databases. We can define these properties on the `resources/META-INF/microprofile-config.properties` or via environment variables. To get more information about Eclipse MicroProfile Config, take a look at its https://microprofile.io/specifications/microprofile-config/[documentation].

According to the `docker-compose.yml` file that we have created previously, we can define the properties like below:

[source, properties]
----
jnosql.mongodb.host=localhost:27017
jnosql.mongodb.user=root
jnosql.mongodb.password=example
jnosql.mongodb.authentication.source=admin
----

=== Modeling the data with Jakarta NoSQL

Once we added the Eclipse JNoSQL dependencies, Jakarta NoSQL api comes together as a transient dependency to the project, allowing us to create the NoSQL entities we want.

Let's modeling the `GameMatch` entity. Such entity will represent each game match result.

As we said before, Eclipse JNoSQL allows us to use Java Records as entities, so, let's use this feature:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.nosql.Column;
import jakarta.nosql.Entity;
import jakarta.nosql.Id;

@Entity
public record GameMatch (
        @Id
        String id,

        @Column
        PlayerInfo playerA,

        @Column
        PlayerInfo playerB,

        @Column
        PlayerInfo winner,

        @Column
        PlayerInfo loser,

        @Column
        Boolean tied
){
}
----

To represent each player name and movement, lets modeling such data as `PlayerInfo` record class:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.nosql.Column;
import jakarta.nosql.Entity;

@Entity
public record PlayerInfo (

        @Column
        String name,

        @Column
        String movement
){
}

----

=== Store and retrieve data with Jakarta Data

Now, in order to store and retrieve such entities from MongoDB database, it's required to create a component that will be responsible to do that. It's common to see developers using patterns like Data Access Object (DAO) to implement these components. That's not a problem at all, but we use to see them making the components closer to a specific vendor database semantics, raising a vendor lock-in situation.

Nowadays, in the cloud era where we pay as we go, switching between NoSQL solutions could be interesting to save resources and costs. Vendor lock-in would compromise this action, probably. Also, other consideration comes to the table when there's a need to switch databases, like: time spent on the change, the learning curve of a new API to use with this database, the code that will be lost, the persistence layer that needs to be replaced, etc. This is where the flexibility of Jakarta NoSQL shines.

Another interesting point is that DAO components tend to be closer to the database semantics than the business domain model language, requiring from developers a high cognitive load to connects the dots and fill the gaps between the technical codes and business necessities, once the code is not expressive enough, and doesn't fit with the ubiquitous language of the business. In this point, Jakarta Data comes to play!

Coming back to our challenge, let's create a repository component that will represents the play-offs:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.data.repository.DataRepository;
import jakarta.data.repository.Query;
import jakarta.data.repository.Repository;
import jakarta.data.repository.Save;

@Repository
public interface Playoffs extends DataRepository<GameMatch,String> {

    @Save
    GameMatch add(GameMatch gameMatch);

}
----

=== Collecting and storing the game matches

With the entity and repository already created, it's needed to capture and persist the results of each game match. The next obvious question is: how could we capture the required game events?

It's a really good question! The answer is: https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0#events[the Events API provided by the Jakarta Context and Dependency Injection (CDI) specification]!

*JNopo* game is using https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0#events[CDI Events] to promote extension points, based on event publishing, to be used as needed. With that, we can implement an `@Observable` methods on any CDI bean to handle event objects.

See below the `GameState` interface. Objects that implements this interface will act as event objects:

[source, java]
----
package org.jakartaee.sample.game;

public sealed interface GameState permits
        WaitingPlayers,
        GameInvalid,
        GameAbandoned,
        GameReady,
        GameRunning,
        GameOver {
    String gameId();
}
----

The `GameState` interface is a sealed interface that defines all the supported game state. According to the sealed implementation, the event that we're interested is the `GameOver` state. Such class is a record class but, it's not just a simple record class that acts like a data transfer object (DTO), it has useful methods that returns important info like:

* The game identification;
* A tied attribute, to know if the game has ended as a tied one;
* The player A and its movement;
* The player B and its movement;
* The winner player and its movement, if the game has ended as a non-tied one.
* The loser player and its movement, if the game has ended as a non-tied one.

Next step: let`s create the `GameMatchCapturer` bean that will be responsible to capture the emitted `GameOver` state and then store the game match results into the database:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import jakarta.inject.Inject;
import org.jakartaee.sample.game.GameOver;

@ApplicationScoped
public class GameMatchCapturer {

    public void captureAndPersist(@Observes GameOver gameOver){
        // put the persistence logic here...
    }

}

----

At this point, let's instantiate a new `GameMatch` entity instance, populate it from `GameOver` data and then store it into the database by using the `Playoffs` component.

The required `Playoff` component, which is a repository implementation offered by Jakarta Data specification implementation, Eclipse JNoSQL, will be injected by CDI using the `@Inject` and `@Database(DOCUMENT)` annotations:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import jakarta.inject.Inject;
import org.eclipse.jnosql.mapping.Database;
import org.eclipse.jnosql.mapping.DatabaseType;
import org.jakartaee.sample.game.GameOver;

@ApplicationScoped
public class GameMatchCapturer {

    @Inject
    @Database(DatabaseType.DOCUMENT)
    Playoffs playoffs;

    public void captureAndPersist(@Observes GameOver gameOver){

            var gameMatch  = new GameMatch(
                    gameOver.gameId(),
                    PlayerInfo.of(gameOver.playerAInfo()),
                    PlayerInfo.of(gameOver.playerBInfo()),
                    gameOver.winnerInfo().map(PlayerInfo::of).orElse(PlayerInfo.NOBODY),
                    gameOver.winnerInfo().map(PlayerInfo::of).orElse(PlayerInfo.NOBODY),
                    gameOver.isTied()
            );

            playoffs.add(gameMatch);
    }

}
----

Now, let's get started the  https://openliberty.io/[Open Liberty] runtime to figure out if the game match results are being stored on the MongoDB:

* On Linux/Mac machines, perform the following command:
+
[source, bash]
----
./mvnw liberty:dev
----

* On Windows machines, perform the following command:
+
[source, powershell]
----
mvnw.cmd liberty:dev
----

After some game matches, we can confirm the persistence of the game matches into the database by looking at Mongo Express running on http://localhost:8081 :

[.img_border_light]
image::/img/blog/mongo-express-01.png[Mongo Express 01, align="center" width=80%]

[.img_border_light]
image::/img/blog/mongo-express-02.png[Mongo Express 02, align="center" width=80%]

[.img_border_light]
image::/img/blog/mongo-express-03.png[Mongo Express 03, align="center" width=80%]

[.img_border_light]
image::/img/blog/mongo-express-04.png[Mongo Express 04, align="center" width=80%]

Or, if you're a command-line practitioner, you can check the data by using the `mongosh` cli:

[source, bash]
----
docker exec -it finish-mongo-1 mongosh -u root -p example --authenticationDatabase admin jnopo
----

Once connected, feel free to perform mongo commands:

* Getting the number of stored documents:
+
[source, bash]
----
jnopo> db.GameMatch.countDocuments()
3
----

* Getting the stored documents list:
+
[source, bash]
----
jnopo> db.GameMatch.find()
[
  {
    _id: '2f42cf9e-f99c-44e5-bda8-7707da2579a3',
    tied: true,
    winner: { name: '', movement: '' },
    playerA: { name: 'Max', movement: 'ROCK' },
    playerB: { name: 'Ghost', movement: 'ROCK' },
    loser: { name: '', movement: '' }
  },
  {
    _id: 'c425815c-2aaf-4caa-a975-8e8089f0a0ce',
    tied: false,
    winner: { name: 'Max', movement: 'PAPER' },
    playerA: { name: 'Ghost', movement: 'ROCK' },
    playerB: { name: 'Max', movement: 'PAPER' },
    loser: { name: 'Max', movement: 'PAPER' }
  },
  {
    _id: 'bb7e7cd5-f8fe-4db1-9e90-44ecd433b4de',
    tied: false,
    winner: { name: 'Ghost', movement: 'ROCK' },
    playerA: { name: 'Ghost', movement: 'ROCK' },
    playerB: { name: 'Max', movement: 'SCISSORS' },
    loser: { name: 'Ghost', movement: 'ROCK' }
  }
]
----

Great! *JNopo* is storing the game match results as expected! It's time to create the winner ranking and then expose it though a restful endpoint http://localhost:9080/jakarta-nosql-game/api/playoffs/ranking .

=== Implementing and exposing the Winner ranking

Collecting and storing the game matches results is a great step to make us able to implement the winner ranking feature.

Let's implement the `Ranking` class to represent any ranking on the *JNopo* application.

The `Ranking` creation requires the data from the `Playoffs` component. In order to avoid to create a new layer to keep the logic of the ranking creation, I decided to use a simple approach: a simple static factory method on the `Ranking` class itself.

Firstly, `Playoffs` needs to provide a method to retrieve the non-tied game results:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.data.repository.DataRepository;
import jakarta.data.repository.Query;
import jakarta.data.repository.Repository;
import jakarta.data.repository.Save;

import java.util.stream.Stream;

@Repository
public interface Playoffs extends DataRepository<GameMatch,String> {

    @Save
    GameMatch add(GameMatch gameMatch);

    @Query("select * from GameMatch where tied=false")
    Stream<GameMatch> nonTiedGameMatches();

}
----

NOTE: *JNoSQL* offers a simple query language pretty similar to SQL but be sure that it's not a complete SQL implementation, which means, some aggregation and functions will be not available.

Regarding the aggregation process that evolves the ranking logic creation, we use to see developers delegating this aggregation logic to the DBMS and, depending on the persistence mechanism, it should be the best approach. By now, the grouping projection functions like we have with Jakarta Persistence is not available on the Jakarta NoSQL for now, but, in the future, such capability could be available as well.

In order to keep our implementation free of vendor lock-in, I decided to implement the aggregation process by using the Stream API. I added comments on the code to help you to understand the implemented logic.

[source, java]
----
package org.jakartaee.sample.model;

import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Collectors;

public record Ranking(Map<String, Integer> data) {
    public static Ranking winnerRanking(Playoffs playoffs) {

        var data =
                // getting the game matches that are not tied
                playoffs.nonTiedGameMatches()
                // grouping by winner's name and summarize by game match
                .collect(Collectors.groupingBy(
                        g -> g.winner().name(),
                        Collectors.collectingAndThen(Collectors.toList(), Collection::size)))
                .entrySet()
                .stream()
                // sorting the results by number of game match in descending order
                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
                // collecting as a LinkedHashMap to keep the sorted items
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        Map.Entry::getValue,
                        (e1, e2) -> e1, LinkedHashMap::new));

        return new Ranking(data);
    }
}
----

Now, let make this ranking be accessible by our model. As the ranking needs the data from `Playoffs` component, why not to put this ranking creation on the `Playoffs` interface? That's we're going to do! It is possible since the Java 8:

[source, java]
----
package org.jakartaee.sample.model;

import jakarta.data.repository.DataRepository;
import jakarta.data.repository.Query;
import jakarta.data.repository.Repository;
import jakarta.data.repository.Save;

import java.util.stream.Stream;

@Repository
public interface Playoffs extends DataRepository<GameMatch,String> {

    @Save
    GameMatch add(GameMatch gameMatch);

    @Query("select * from GameMatch where tied=false")
    Stream<GameMatch> nonTiedGameMatches();

    default Ranking winnerRanking(){
       return Ranking.winnerRanking(this);
    }
}
----

It looks like we're getting closer to our goal!

Following the challenge requirements, let's create the resource component that will expose the winner ranking.

Firstly, let's create the `RestApplication` class to define the url dedicated to restful endpoints:
[source, java]
----
package org.jakartaee.sample.resources;

import jakarta.ws.rs.ApplicationPath;
import jakarta.ws.rs.core.Application;

@ApplicationPath("/api")
public class RestApplication extends Application {

}
----

Now, any url under `/api` will be handled by the Jakarta Restful Webservices implementation available in our runtime environment.

Next step: let's implement the `PlayoffsResource` resource. This component will expose an HTTP GET endpoint for the `/api/playoffs/ranking` url:

[source, java]
----
package org.jakartaee.sample.resources;

import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import org.eclipse.jnosql.mapping.Database;
import org.eclipse.jnosql.mapping.DatabaseType;
import org.jakartaee.sample.model.Playoffs;
import org.jakartaee.sample.model.Ranking;

@Path("/playoffs")
@Consumes({MediaType.APPLICATION_JSON})
@Produces({MediaType.APPLICATION_JSON})
public class PlayoffsResource {

    @Inject
    @Database(DatabaseType.DOCUMENT)
    Playoffs playoffs;

    @GET
    @Path("/ranking")
    public Ranking getRanking() {
        return playoffs.winnerRanking();
    }
}
----

It's time to test everything! Let's restart the https://openliberty.io/[Open Liberty] runtime:

* On Linux/Mac machines, perform the following command:
+
[source, bash]
----
./mvnw liberty:dev
----

* On Windows machines, perform the following command:
+
[source, powershell]
----
mvnw.cmd liberty:dev
----

https://openliberty.io/[Open Liberty]  provides us an amazing tooling to help during the development of Jakarta EE / MicroProfile applications. When the dev mode is running, we can use some HTTP addresses to test and explore the capabilities offered by this amazing Jakarta EE/MicroProfile runtime:

[source, console]
----
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/openapi/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/health/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/jwt/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/metrics/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/openapi/ui/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/ibm/api/
[INFO] [AUDIT   ] CWWKT0016I: Web application available (default_host): http://localhost:9080/jakarta-nosql-game/
----

In this blog post, let's focus on two of these url:

* http://localhost:9080/jakarta-nosql-game/ : it's the url of the application that we can use locally;

* http://localhost:9080/openapi/ui/ : it's the Swagger UI interface that  https://openliberty.io/[Open Liberty]  offers out-of-the-box, facilitating the rest endpoint testing via browser.

[.img_border_light]
image::/img/blog/swagger-ui-01.png[Swagger UI 01, align="center" width=80%]

[.img_border_light]
image::/img/blog/swagger-ui-02.png[Swagger UI 02, align="center" width=80%]


If you're a command-line practitioner, you can check the data by using the `curl` command:

[source, bash]
----
curl -X 'GET' \
  'http://localhost:9080/jakarta-nosql-game/api/playoffs/ranking' \
  -H 'accept: application/json' | jq
----

[source, json]
----
{
  "data": {
    "Max": 3,
    "Ghost": 1
  }
}
----

Congratulations if you made it this far!

Now, *JNopo* is providing a winner ranking!

If you're interesting to take a look on the finished project code version developed during this challenge, clone this https://github.com/OpenLiberty/sample-jakartaNoSQL-game[Git repository], checkout the `winner-ranking-challenge`, and then navigate to the `finish` directory.

[source, bash]
----
git clone https://github.com/OpenLiberty/sample-jakartaNoSQL-game.git
cd sample-jakartaNoSQL-game
git checkout winner-ranking-challenge
cd finish
----


=== Switching to another Document NoSQL Database

Nowadays, in the cloud era, switching between NoSQL solutions could be interesting to save resources and costs, but it could be a nightmare, specially if we're highly coupled to a particular vendor. It will cause some changes that will make this approach very expensive, like: time spent on the change, the learning curve of a new API to use with this database, the code that will be lost, the persistence layer that needs to be replaced, etc.

This is where the flexibility of Jakarta NoSQL with an implementation like Eclipse JNoSQL together shines.

To explore this capability, let's suppose that it's needed to change the Document NoSQL database used by the *JNopo* application, MongoDB, to another Document NoSQL database for save money purposes, e.g. Couchbase.

Just a few changes, we'll be able to archive this goal easily.

==== Adding Eclipse JNoSQL Database API for Couchbase dependency

In the `pom.xml` file, add the following dependency:

[source, xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-couchbase</artifactId>
  <version>1.1.0</version>
</dependency>
----


==== Setting up a local Couchbase cluster

Add the following content to the `docker-compose.yml` file:

[source, yaml]
----
  couchbase-db:
    image: couchbase
    container_name: couchbase-db
    ports:
      - "8091-8097:8091-8097"
      - "9123:9123"
      - "11207:11207"
      - "11210:11210"
      - "11280:11280"
      - "18091-18097:18091-18097"
----

After to apply these changes, initialize the container by executing the following command:

[source, bash]
----
docker-compose up -d
----

Now, let's configure the Couchbase cluster for this study scenario:

. With the Couchbase container started, go to: http://localhost:8091/ui/index.html
. Select the "Configure New Cluster" option
+
[.img_border_light]
image::/img/blog/couchbase-01.png[Couchbase 01, align="center" width=80%]
. Defines a name for the cluster name
. Set `root` to "Administrator" username
. Set `123456` as "Password"
+
[.img_border_light]
image::/img/blog/couchbase-02.png[Couchbase 02, align="center" width=80%]
. Check “I accept the terms and conditions” and click the “Finish With Defaults” button
+
[.img_border_light]
image::/img/blog/couchbase-03.png[Couchbase 03, align="center" width=80%]
. Go to the "Buckets" section
. Create a `jnopo` Bucket by clicking on the "Add Bucket" option
+
[.img_border_light]
image::/img/blog/couchbase-04.png[Couchbase 04, align="center" width=80%]
. Click on "Scopes & Collections" and then click on "Add Collection"
. Enter `GameMatch` as the collection name and click the "Save" button to complete your creation
+
[.img_border_light]
image::/img/blog/couchbase-05.png[Couchbase 05, align="center" width=80%]
. Now, in the "Query" section, run this command https://www.couchbase.com/products/n1ql/[N1QL] to create the primary index for the `GameMatch` collection:
+
[source, n1ql]
----
CREATE PRIMARY INDEX primaryGameMatch ON jnopo._default.GameMatch
----
+
[.img_border_light]
image::/img/blog/couchbase-06.png[Couchbase 06, align="center" width=80%]

With a Couchbase cluster running, we just need to set up Eclipse JNoSQL to connect to it.

Apply the following changes into the `resources/META-INF/microprofile-config.properties` file:

[source, properties]
----
## Couchbase
jnosql.couchbase.host=couchbase://localhost
jnosql.couchbase.user=root
jnosql.couchbase.password=123456
jnosql.document.provider=org.eclipse.jnosql.databases.couchbase.communication.CouchbaseDocumentConfiguration
----

The `jnosql.document.provider` property is required in this context because we have more than one Eclipse JNoSQL Database API for Document NoSQL implementations. Learn more about these configurations about Eclipse JNoSQL Database API for Couchbase at this https://github.com/eclipse/jnosql-databases/tree/main?tab=readme-ov-file#configuration-2[Git repository].

That's all! Let's restart the https://openliberty.io/[Open Liberty] runtime in order to be able to make sure that everything is running smoothly:

* On Linux/Mac machines, perform the following command:
+
[source, bash]
----
./mvnw liberty:dev
----

* On Windows machines, perform the following command:
+
[source, powershell]
----
mvnw.cmd liberty:dev
----

After some game matches, here are the evidences:

[.img_border_light]
image::/img/blog/couchbase-verification-01.png[Couchbase Verification 01, align="center" width=80%]
[.img_border_light]
image::/img/blog/couchbase-verification-02.png[Couchbase Verification 02, align="center" width=80%]

If you're interesting to take a look on the finished project code version developed during this challenge, clone this https://github.com/OpenLiberty/sample-jakartaNoSQL-game[Git repository], checkout the `database-switching`, and then navigate to the `finish` directory.

[source, bash]
----
git clone https://github.com/OpenLiberty/sample-jakartaNoSQL-game.git
cd sample-jakartaNoSQL-game
git checkout database-switching
cd finish
----

== Takeaways

These challenges were an amazing opportunities to learn not just about Jakarta NoSQL and Jakarta Data to simplify the NoSQL integration with Java applications but be exploring new development approaches using interesting Java features.

What we got by doing these challenges:

* A practical example that uses:
** Sealed classes (final feature since Java 17)
** Pattern Matching for Instanceof (final feature since Java 16)
** Pattern Matching for Switch (final feature since Java 21);


What we learned from them:

* How to configure Eclipse JNoSQL to allow us to work with Jakarta NoSQL and Jakarta Data in a Jakarta EE / MicroProfile project;
* How to work with Jakarta NoSQL to create entities pretty similar to Jakarta Persistence approach;
* How to create repositories with Jakarta Data, the newest Jakarta EE Specification that will be available in the Jakarta EE 11;
* How to switch between NoSQL database from different vendors, in our example: switching MongoDB to Couchbase;

== Nice work! Where to next?

Congratulations on getting this far!

To see more sample projects, take a look at the official Eclipse JNoSQL samples repositories:

- https://github.com/jnosql/demos-se
- https://github.com/JNOSQL/demos-ee


To learn more about Eclipse JNoSQL, take a look at these official repositories:

- https://github.com/eclipse/jnosql
- https://github.com/eclipse/jnosql-databases
- https://github.com/eclipse/jnosql-extensions

if you're an expert on some NoSQL database that Eclipse JNoSQL doesn't support, feel free to open an issue or a PR on the project repositories mentioned above.

Except for the NoSQL solutions mentioned like MongoDB and Couchbase, all the technology used in this blog post are open-source, so, what do you think about contributing to these projects?

If you don't know how to get started to contribute, take a look at this https://www.youtube.com/live/7qhHOOoZEBU?feature=share[Coffee.withJava("Contribute to JNoSQL") Youtube Series].

Contributing to these projects is not just with codes, you could help a lot by promoting and speaking about them wherever you go!

Contributing to open-source is a great way to boost your career, and improve your skills to become an effective developer and relevant in the market! Think about that!

== References

* Official documentation:
** https://jnosql.org[Eclipse JNoSQL website]
** https://jakarta.ee/specifications/[Jakarta EE Specifications]

* Articles:
** https://dzone.com/articles/jakarta-nosql-100-b5-how-to-make-your-life-easier[Jakarta NoSQL 1.0.0-b5: How To Make Your Life Easier Around Enterprise Java and NoSQL Databases by Otavio Santana]
** https://dzone.com/articles/eclipse-jnosql-100-streamlining-java-and-nosql-int[Eclipse JNoSQL 1.0.0: Streamlining Java and NoSQL Integration With New Features and Bug Fixes by Otavio Santana]
** https://dzone.com/articles/mastering-java-persistence-best-practices-for-clou[Mastering Java Persistence: Best Practices for Cloud-Native Applications and Modernization by Otavio Santana]
** https://dzone.com/articles/eclipse-jnosql-102-empowering-java-with-nosql-data[Eclipse JNoSQL 1.0.2: Empowering Java With NoSQL Database Flexibility by Otavio Santana]
** https://blogs.oracle.com/nosql/post/getting-started-accessing-oracle-nosql-database-using-jakarta-nosql[Getting Started - Accessing Oracle NoSQL Database using Jakarta NoSQL by Dario VEGA]
** https://dzone.com/articles/exploring-the-new-eclipse-jnosql-version-110-a-div[Exploring the New Eclipse JNoSQL Version 1.1.0: A Dive Into Oracle NoSQL by Otavio Santana]
** https://eldermoraes.com/how-to-create-cdi-events/[How to create CDI Events by Elder Moraes]
** https://blogs.oracle.com/javamagazine/post/jakarta-data-mysql[Simplifying data access with MySQL and Jakarta Data by Ivar Grimstad]
** https://dzone.com/articles/introduction-to-nosql-database-1[Introduction to NoSQL Database by Rama Krishna Panguluri];

* Books:
** https://www.amazon.com/Persistence-Best-Practices-Java-Applications/dp/1837631271/[Persistence Best Practices for Java Applications by Otavio Santana and Karina Varela]
** https://a.co/d/4dlvHQj[NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence by Pramod Sadalage and Martin Fowler]

